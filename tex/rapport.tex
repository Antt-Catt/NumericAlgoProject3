\documentclass{article}

\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[]{amsmath}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{hyperref}

%%%%%%%%%%%%%%%% Lengths %%%%%%%%%%%%%%%%
\setlength{\textwidth}{15.5cm}
\setlength{\evensidemargin}{0.5cm}
\setlength{\oddsidemargin}{0.5cm}

%%%%%%%%%%%%%%%% Variables %%%%%%%%%%%%%%%%
\def\projet{3}
\def\titre{Compression d'image à travers la factorisation SVD}
\def\groupe{4}
\def\equipe{6}
\def\responsible{jeamartinez}
\def\secretary{acattarin}
\def\others{mchellaf, siducamp}

\begin{document}

%%%%%%%%%%%%%%%% Header %%%%%%%%%%%%%%%%
\noindent\begin{minipage}{0.98\textwidth}
  \vskip 0mm
  \noindent
  { \begin{tabular}{p{7.5cm}}
      {\bfseries \sffamily
        Projet \projet} \\ 
      {\itshape \titre}
    \end{tabular}}
  \hfill 
  \fbox{\begin{tabular}{l}
      {~\hfill \bfseries \sffamily Groupe \groupe\ - Equipe \equipe
        \hfill~} \\[2mm] 
      Responsable : \responsible \\
      Secrétaire : \secretary \\
      Codeurs : \others
    \end{tabular}}
  \vskip 4mm ~

  ~~~\parbox{0.95\textwidth}{\small \textit{Résumé~:Le but de ce projet 
  consiste à programmer un algorithme permettant de faire de la compression 
  d'images en utilisant des techniques matricielles basée sur la factorisation SVD.
  Ce type d'algorithme est à relier aux algorithmes de compression avec pertes, 
  dont le plus connu est certainement l'algorithme de compression JPEG, 
  lui-même basé usuellement sur la Discrete Cosine Transform (DCT), une transformation voisine de la transformée de Fourier discrète.} \sffamily }
  \vskip 1mm ~
\end{minipage}

%%%%%%%%%%%%%%%% Main part %%%%%%%%%%%%%%%%
\section{Transformation de Householder}
\label{sec:transfo_householder}

\subsection{Construction d'une matrice de Householder}
\label{ssec:construc_householder}

\subsection{Application d'une matrice de Householder}
\label{ssec:appli_householder}

Soient deux vecteurs $\vec{u}$ et $\vec{v}$ dont on déduit une matrice de Householder $H_{\vec{u},\vec{v}}$.
Soit un vecteur $\vec{a}$ sur lequel on veut appliquer la matrice de Householder. Les vecteurs sont tous de longueur $n$.

On va utiliser la réécriture $H = I_d - 2 \times N \cdot N^t$ pour écrire un algorithme optimisé de l'application
de $H_{\vec{u},\vec{v}}$.

\begin{align}
  \label{eq:opti_app_hh}
  H_{\vec{u},\vec{v}} \cdot \vec{a} &= (I_d - 2 \times N \cdot N^t) \cdot \vec{a} \\
                                    &= \vec{a} - 2 \times N \cdot N^t \cdot \vec{a} \\
                                    &= \vec{a} - 2 \times N \cdot \underbrace{(N^t \cdot \vec{a})}_{\text{scalaire}} \\
                                    &= \vec{a} - 2 \times \underbrace{(N^t \cdot \vec{a})}_{\text{scalaire}} \cdot N
\end{align}

Alors on peut en déduire un algorithme qui va appliquer directement la matrice $H_{\vec{u},\vec{v}}$ sur $\vec{a}$ à
partir de $\vec{u}$ et $\vec{v}$, et ce en utilisant un unique produit scalaire. Sa complexité est donc en $O(n)$

\subsection{Etude de compléxité}
\label{ssec:complex_householder}

Soient une matrice $A$ représentant un ensemble de vecteurs et deux vecteurs $\vec{u}$ et $\vec{v}$ dont
on déduit une matrice de Householder $H_{\vec{u},\vec{v}}$
Appelons $n$ la taille de chacun des vecteurs. \newline

Le produit matriciel entre $H_{\vec{u},\vec{v}}$ et $A$ naïf requiert en premier lieu la construction de 
la matrice de Householder $H_{\vec{u},\vec{v}}$ en brut. L'algorithme construisant la matrice de Householder
effectue une multiplication matrice-vecteur de complexité $O(n^2)$. Par la suite, la multiplication matrice-matrice
entre $H_{\vec{u},\vec{v}}$ et $A$ va demander une complexité $O(n^3)$, en effet l'algorithme fait pour chaque
case $(i,j)$ de la matrice un produit scalaire ligne-colonne de complexité $O(n)$, en sachant que $H_{\vec{u},\vec{v}}$ a $n$ lignes
et colonnes.

Le produit matriciel entre $H_{\vec{u},\vec{v}}$ et $A$ optimisé va utiliser la réécriture de la matrice de Householder :
$H = I_d - 2 \times N \cdot N^t$. 
On va utiliser l'application de la matrice de Householder présentée dans la sous-section \ref{ssec:appli_householder} sur 
chaque vecteur colonne de la matrice $A$, sachant que cette application est en complexité $O(n)$ (un simple produit scalaire).
L'algorithme ne va alors effectuer qu'un produit vectoriel par colonne de la matrice $A$, ce qui nous donne une complexité en $O(n^2)$.

\section{Mise sous forme bidiagonale}
\label{sec:forme_bidiag_}

\subsection{Implémentation}
\label{ssec:implem_bidiag_}

\subsection{Analyse}
\label{ssec:analyse_bidiag}


\section{Transformations QR}
\label{sec:transfo_qr}

\subsection{Implémentation}
\label{ssec:implem_qr}

\subsection{Etude de convergence}
\label{ssec:conv_qr}

\subsection{Analyse}
\label{ssec:analyse_qr}

La matrice $S$ est bidiagonale dès le début de la fonction.

Pour chaque itération de la boucle \verb|for| de la fonction \verb|transfo_qr| :
\smallskip

\noindent La matrice $R1$ est obtenue grâce à une décomposition QR de $S$.

\noindent La matrice $R2$ est obtenue grâce à une décomposition QR de $R2$.

\noindent La matrice $S$ prend les valeurs de $R2$.

\smallskip
Or, la matrice obtenue avec une décomposition QR d'une matrice bidiagonale est également bidiagonale. %à prouver ?

A la première itération, $R1$ est donc bidiagonale (issue de la décomposition QR de $S$). De même, $R2$ est également bidiagonale. Finalement, $S$ prend les valeurs de $R2$. L'invariant est donc vrai après la première itération.

\smallskip

Nous prouvons l'induction exactement de la même manière, puisque nous supposons que $S$ est bidiagonale au début de l'itération.

\subsection{Optimisation pour une matrice bidiagonale}
\label{ssec:opti_bidiag_qr}

\subsection{Mise en forme}
\label{ssec:mise_en_forme_qr}


\section{Application à la compression d'image}
\label{sec:appli_compr_img}

\subsection{Compression}
\label{ssec:compr_img}

\subsection{Analyse quantitative}
\label{ssec:quanti_img}

\subsection{Analyse qualitative}
\label{ssec:quali_img}

\end{document}
